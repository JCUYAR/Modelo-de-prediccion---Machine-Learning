# -*- coding: utf-8 -*-
"""MODELO ML FINAL TESIS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13nPaiYj05is9aDe1eEYSweV0cJX7v4j9

FASE 1 - Entendimiento del negocio

Regalitos.com.pe es una tienda especializada en la venta en línea de una amplia gama de artículos diseñados para realzar la belleza y el bienestar personal. Fundada por la Doctora en derecho, Lissette Lourdez Rodriguez Zamudio, con la pasión por ofrecer soluciones de belleza de alta calidad y la comodidad de las compras en línea.
Con el propósito de mejorar continuamente y satisfacer las necesidades de sus clientes, estamos implementando nuevas estrategias tecnológicas. El objetivo es predecir las ventas totales para los años 2024-2025 utilizando un modelo de machine learning basado en datos históricos de ventas.

FASE 2 - Entendimiento de los datos
"""

import pandas as pd
from google.colab import files
import io
from tabulate import tabulate
from prettytable import PrettyTable
from sklearn.model_selection import cross_val_score, train_test_split, cross_validate
from sklearn.ensemble import StackingRegressor, RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as ticker
import numpy as np

# Función para cargar el archivo en Google Colab
def cargar_archivo_colab():
    uploaded = files.upload()
    for filename in uploaded.keys():
        content = io.StringIO(uploaded[filename].decode('utf-8'))
        return pd.read_csv(content)

# Cargar los datos usando la función
data = cargar_archivo_colab()
# Imprimir las primeras filas usando tabulate
print("\nDataFrame 'data' después de transformaciones:")
print(tabulate(data.head(), headers='keys', tablefmt='fancy_grid'))

"""FASE 3 - Preparación de los datos"""

# Convertir la columna de fecha a características numéricas
data['fecha_anio'] = pd.to_datetime(data['Invoice Date'], format='%d-%m-%Y').dt.year
data['fecha_mes'] = pd.to_datetime(data['Invoice Date'], format='%d-%m-%Y').dt.month
data['fecha_dia'] = pd.to_datetime(data['Invoice Date'], format='%d-%m-%Y').dt.day

# Eliminar la columna original de fecha
data = data.drop('Invoice Date', axis=1)

# Convertir características categóricas a variables dummy
categorical_cols = data.select_dtypes(include=['object']).columns
data = pd.get_dummies(data, columns=categorical_cols, drop_first=True)

# Filtrar los datos solo para el año 2023
data_2023 = data[data['fecha_anio'] == 2023]

# Obtener las columnas relevantes para el entrenamiento (excluyendo la columna objetivo)
feature_columns = [col for col in data_2023.columns if col != 'Total Sales']

X = data_2023[feature_columns]
y = data_2023['Total Sales'].values.ravel()

# Obtener los primeros registros (head) de data_2023
primeros_registros = data_2023.head()

# Crear la tabla con PrettyTable
tabla_primeros_registros = PrettyTable()
tabla_primeros_registros.field_names = primeros_registros.columns

# Agregar filas a la tabla
for row in primeros_registros.itertuples(index=False):
    tabla_primeros_registros.add_row(row)

print("Primeros registros de data_2023:")
print(tabulate(primeros_registros, headers='keys', tablefmt='fancy_grid'))

# Obtener el resumen estadístico (describe) de data_2023
resumen_estadistico = data_2023.describe()

# Convertir el DataFrame de resumen estadístico a una lista de listas
tabla_resumen_estadistico = resumen_estadistico.reset_index().values.tolist()

# Obtener los nombres de las columnas como encabezados
headers = resumen_estadistico.reset_index().columns.tolist()

# Imprimir la tabla usando tabulate para formato 'fancy_grid'
print("\nResumen estadístico de data_2023:")
print(tabulate(tabla_resumen_estadistico, headers=headers, tablefmt='fancy_grid'))

"""FASE 4 - Modelado"""

# División de los datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Definir modelos base
modelos_base = [
    ('gb', GradientBoostingRegressor(n_estimators=1000, learning_rate=0.1, max_depth=6, random_state=70)),
    ('dt', DecisionTreeRegressor(random_state=70, max_depth=6)),
    ('rf', RandomForestRegressor(n_estimators=100, max_depth=6,random_state=70))
]

# Crear el modelo de Stacking
model_stacked = StackingRegressor(
    estimators=modelos_base,
    final_estimator=LinearRegression()
)

# Inicializar diccionario para almacenar resultados
resultados = {}

# Calcular métricas para cada modelo base y el modelo stacking
for nombre, modelo in modelos_base:
    # Validación cruzada metodo k-fold para MSE, MAE y R^2
    scores = cross_validate(modelo, X_train, y_train, cv=5, scoring=('neg_mean_squared_error', 'neg_mean_absolute_error', 'r2'))
    resultados[nombre] = {
        'mse': -scores['test_neg_mean_squared_error'],
        'mae': -scores['test_neg_mean_absolute_error'],
        'r2': scores['test_r2']
    }

# Imprimir las métricas de cada modelo base y el modelo de Stacking
print("\nMétricas de los modelos:")
for nombre, metricas in resultados.items():
    print(f"\nModelo: {nombre}")
    print(f"MSE: {np.mean(metricas['mse'])} (+/- {np.std(metricas['mse'])})")
    print(f"MAE: {np.mean(metricas['mae'])} (+/- {np.std(metricas['mae'])})")
    print(f"R^2: {np.mean(metricas['r2'])} (+/- {np.std(metricas['r2'])})")

# Graficar los resultados de validación cruzada
fig, ax = plt.subplots(1, 3, figsize=(18, 6))

for i, metric in enumerate(['mse', 'mae', 'r2']):
    ax[i].boxplot([resultados[modelo][metric] for modelo in resultados.keys()], labels=resultados.keys())
    ax[i].set_title(f'Validación Cruzada - {metric.upper()}')
    ax[i].set_ylabel(metric.upper())
    ax[i].grid(True)

plt.tight_layout()
plt.show()

# Entrenar el modelo de Stacking con los datos de 2023
model_stacked.fit(X_train, y_train)

# Realizar la predicción en el conjunto de prueba
y_pred = model_stacked.predict(X_test)

# Calcular métricas de rendimiento en el conjunto de prueba
mse_test = mean_squared_error(y_test, y_pred)
mae_test = mean_absolute_error(y_test, y_pred)
r2_test = r2_score(y_test, y_pred)

# Calcular métricas de rendimiento en el conjunto de entrenamiento
y_pred_train = model_stacked.predict(X_train)
mse_train = mean_squared_error(y_train, y_pred_train)
mae_train = mean_absolute_error(y_train, y_pred_train)
r2_train = r2_score(y_train, y_pred_train)

print("\nMétricas del modelo en conjunto de entrenamiento:")
print(f"MSE: {mse_train}")
print(f"MAE: {mae_train}")
print(f"R^2: {r2_train}")

print("\nMétricas del modelo en conjunto de prueba:")
print(f"MSE: {mse_test}")
print(f"MAE: {mae_test}")
print(f"R^2: {r2_test}")

# Gráfico de predicciones vs valores reales para entrenamiento y prueba
plt.figure(figsize=(12, 6))

# Gráfico para entrenamiento
plt.subplot(1, 2, 1)
plt.scatter(y_train, y_pred_train, color='blue', label='Predicciones Entrenamiento')
plt.plot([min(y_train), max(y_train)], [min(y_train), max(y_train)], color='red', linestyle='--', label='Línea de 45°')
plt.title('Predicciones vs Valores Reales - Entrenamiento')
plt.xlabel('Valores Reales')
plt.ylabel('Predicciones')
plt.legend()
plt.grid(True)

# Gráfico para prueba
plt.subplot(1, 2, 2)
plt.scatter(y_test, y_pred, color='green', label='Predicciones Prueba')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--', label='Línea de 45°')
plt.title('Predicciones vs Valores Reales - Prueba')
plt.xlabel('Valores Reales')
plt.ylabel('Predicciones')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Calcular la suma de las ventas totales por año
ventas_2023 = data[data['fecha_anio'] == 2023]['Total Sales'].sum()

# Realizar la predicción para los datos de 2024
predicciones_2024 = model_stacked.predict(X)

# Actualizar los datos de entrenamiento con las predicciones de 2024
X_train2024 = X.copy()
X_train2024['Total Sales'] = predicciones_2024
y_train2024 = predicciones_2024

# Entrenar el modelo de Stacking con los datos de 2024
model_stacked.fit(X_train2024, y_train2024)

# Realizar la predicción para los datos de 2025
predicciones_2025 = model_stacked.predict(X_train2024)

# Actualizar los datos de entrenamiento con las predicciones de 2025
X_train2025 = X_train2024.copy()
X_train2025['Total Sales'] = predicciones_2025
y_train2025 = predicciones_2025

"""FASE 5 - Evaluación"""

# Calcular las métricas para los años 2024 y 2025
mse_2024 = mean_squared_error(y, predicciones_2024)
mae_2024 = mean_absolute_error(y, predicciones_2024)
r2_2024 = r2_score(y, predicciones_2024)

mse_2025 = mean_squared_error(y, predicciones_2025)
mae_2025 = mean_absolute_error(y, predicciones_2025)
r2_2025 = r2_score(y, predicciones_2025)

# Datos para las tablas
data_metrics = [
    ['2024 (Pred)', mse_2024, mae_2024, r2_2024],
    ['2025 (Pred)', mse_2025, mae_2025, r2_2025]
]

# Tabla con tabulate
tabla_metrics = tabulate(data_metrics, headers=['Año', 'MSE', 'MAE', 'R^2'], tablefmt='fancy_grid')
print("\nMétricas del modelo:")
print(tabla_metrics)

"""FASE 6 - Despliegue"""

# Imprimir la suma de las ventas totales por año
print(f"\nVentas totales para el año 2023: ${ventas_2023:,.2f}")
print(f"Suma de las predicciones para el año 2024: ${predicciones_2024.sum():,.2f}")
print(f"Suma de las predicciones para el año 2025: ${predicciones_2025.sum():,.2f}")


# Gráfico de predicciones vs valores reales para el año 2024 con valor de R^2
plt.figure(figsize=(8, 6))
plt.scatter(y, predicciones_2024, color='blue', label='Predicciones 2024')
plt.plot([min(y), max(y)], [min(y), max(y)], color='red', linestyle='--', label='Línea de 45°')
plt.title('Predicciones vs Valores Reales para el Año 2024')
plt.xlabel('Valores Reales')
plt.ylabel('Predicciones')
plt.text(0.95, 0.05, f'R^2 = {r2_2024}', ha='right', va='bottom', transform=plt.gca().transAxes, bbox=dict(facecolor='white', alpha=0.5))
plt.grid(True)
plt.legend()
plt.show()

# Gráfico de predicciones vs valores reales para el año 2025 con valor de R^2
plt.figure(figsize=(8, 6))
plt.scatter(y, predicciones_2025, color='green', label='Predicciones 2025')
plt.plot([min(y), max(y)], [min(y), max(y)], color='red', linestyle='--', label='Línea de 45°')
plt.title('Predicciones vs Valores Reales para el Año 2025')
plt.xlabel('Valores Reales')
plt.ylabel('Predicciones')
plt.text(0.95, 0.05, f'R^2 = {r2_2025}', ha='right', va='bottom', transform=plt.gca().transAxes, bbox=dict(facecolor='white', alpha=0.5))
plt.grid(True)
plt.legend()
plt.show()

# Gráfico de predicciones de ventas para los años 2024-2025
predicciones = pd.DataFrame({
    'Año': [2024, 2025],
    'Total Sales Predicción': [predicciones_2024.sum(), predicciones_2025.sum()]
})

plt.figure(figsize=(12, 8))
plt.plot(predicciones['Año'], predicciones['Total Sales Predicción'], marker='o')
for i, txt in enumerate(predicciones['Total Sales Predicción']):
    plt.annotate(f'${txt:,.2f}', (predicciones['Año'][i], predicciones['Total Sales Predicción'][i]), textcoords="offset points", xytext=(0, 10), ha='center')

plt.xlabel('Año')
plt.ylabel('Total Sales')
plt.title('Predicciones de ventas para los años 2024-2025')
plt.gca().yaxis.set_major_formatter(ticker.StrMethodFormatter('{x:,.0f}'))
plt.grid(True)
plt.show()